<!doctype html>
<html lang="pt-PT">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Background Pr</title>
<style>
  /* video continua no fundo */
  #player {
    position:fixed;
    inset:0;
    z-index:-2;
    pointer-events:none;
    background:#000;
  }

  /* overlay agora ocupa toda a tela */
  .ui {
    position:fixed;
    inset:0;
    z-index:1;
    display:flex;
    flex-direction:column;
    justify-content:space-between;
    pointer-events:none; /* apenas elementos internos com pointer-events:auto recebem cliques */
  }

  .controls {
    width:100%;
    height:100%;
    padding:0;
    display:flex;
    flex-direction:column;
    justify-content:space-between;
    pointer-events:auto;
    background: rgba(0,0,0,0.9); /* leve transpar√™ncia para visualizar o v√≠deo atr√°s */
  }

  .top-row {
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:16px 24px;
  }

  .row { display:flex; gap:10px; align-items:center; }

  .btn {
    background:rgba(0,0,0,0.4);
    border:1px solid rgba(255,255,255,0.2);
    padding:8px 12px;
    border-radius:10px;
    cursor:pointer;
    color:#fff;
    font-size:16px;
    user-select:none;
    display:inline-flex;
    align-items:center;
    justify-content:center;
  }

  .btn:active { transform:scale(0.95); }

  .center-row {
    display:flex;
    justify-content:center;
    align-items:center;
    padding:12px 24px;
    gap:16px;
  }

  .progress {
    width:100%;
    height:8px;
    background:rgba(255,255,255,0.1);
    border-radius:4px;
    cursor:pointer;
    position:relative;
  }

  .progress .bar {
    position:absolute;
    left:0;
    top:0;
    height:100%;
    background:linear-gradient(90deg, #00c8ff, #008cff);
    width:0%;
    border-radius:4px;
  }

  .time {
    color:#fff;
    font-size:14px;
    min-width:60px;
    text-align:right;
  }

  input[type="range"] {
    -webkit-appearance:none;
    appearance:none;
    height:6px;
    border-radius:6px;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance:none;
    width:14px;
    height:14px;
    border-radius:50%;
    background:#fff;
    margin-top:-4px;
  }

  /* coloca os controles de baixo sempre na parte inferior da tela */
  .bottom-row {
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:16px 24px;
    gap:16px;
  }

  /* responsividade */
  @media (max-width:520px){
    .top-row { flex-direction:column; align-items:flex-start; gap:8px; }
    .center-row { flex-direction:column; gap:12px; }
  }
</style>

</head>
<body>

<!-- PLAYER (YouTube IFrame API) -->
<div id="player"></div>

<!-- UI por cima -->
<div class="ui">
  <div class="controls">
    <!-- topo: t√≠tulo + bot√µes principais -->
    <div class="top-row">
      <!-- <div class="title" id="trackTitle">A carregar playlist...</div> -->
      <div class="row">
        <button class="btn" id="prevBtn">‚ü≤</button>
        <button class="btn" id="playPauseBtn">‚ñ∂</button>
        <button class="btn" id="nextBtn">‚ü≥</button>
      </div>
    </div>

    <!-- centro: barra de progresso -->
    <div class="center-row">
      <div class="progress" id="progress">
        <div class="bar" id="progressBar"></div>
      </div>
      <div class="time" id="timeLabel">0:00 / 0:00</div>
    </div>

    <!-- baixo: volume, mute, shuffle, loop -->
    <div class="bottom-row">
      <div class="row">
        <button class="btn" id="muteBtn">üîä</button>
        <input id="vol" type="range" min="0" max="100" value="100">
      </div>
      <div class="row">
        <button class="btn" id="shuffleBtn">üîÄ</button>
        <button class="btn" id="loopBtn">üîÅ</button>
      </div>
    </div>
  </div>
</div>


<script>
  /////////////////////////////////////////////////////////////////////////////
  // CONFIG https://www.youtube.com/watch?v=Sq0SO-bzHZE&list=PLaF8FbChcxg6wfsLJqVkrD19oqKdvmv7I
  // Substitui por uma playlist tua (IDs sem "PL" funcionam tamb√©m se for playlist p√∫blica)
  const PLAYLIST_ID = 'PLaF8FbChcxg6wfsLJqVkrD19oqKdvmv7I';
  // Se preferires um v√≠deo ID para come√ßar, define START_INDEX. Caso contr√°rio come√ßa no primeiro.
  const START_INDEX = 0;
  /////////////////////////////////////////////////////////////////////////////

  // script da API
  let tag = document.createElement('script');
  tag.src = "https://www.youtube.com/iframe_api";
  document.head.appendChild(tag);

  // vari√°veis
  let player;
  let isPlaying = false;
  let isMuted = false;
  let shuffle = true;
  let loop = true;
  let updateTimer = null;
  let playlistOrder = []; // array de videoIds (ordem atual)
  let currentIndex = START_INDEX;

  // elementos UI
  const playPauseBtn = document.getElementById('playPauseBtn');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const volSlider = document.getElementById('vol');
  const muteBtn = document.getElementById('muteBtn');
  const progress = document.getElementById('progress');
  const progressBar = document.getElementById('progressBar');
  const timeLabel = document.getElementById('timeLabel');
  const trackTitle = document.getElementById('trackTitle');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const loopBtn = document.getElementById('loopBtn');

  // cria o player depois que a API carregar
  function onYouTubeIframeAPIReady() {
    player = new YT.Player('player', {
      height: '100%',
      width: '100%',
      playerVars: {
        listType: 'playlist',
        list: PLAYLIST_ID,
        autoplay: 1,         // tentativa de autoplay
        controls: 0,         // esconde controls nativos
        rel: 0,
        modestbranding: 1,
        showinfo: 0,
        origin: location.origin,
        mute: 1              // tenta iniciar mudo para permitir autoplay
      },
      events: {
        'onReady': onPlayerReady,
        'onStateChange': onPlayerStateChange,
        'onError': onPlayerError
      }
    });
  }

  // quando estiver pronto
  function onPlayerReady(event) {
    // obter a lista de reprodu√ß√£o completa via m√©todo da API (assincrono)
    // getPlaylist returns array of videoIds
    const list = player.getPlaylist();
    if (Array.isArray(list) && list.length) {
      playlistOrder = list.slice();
      currentIndex = Math.min(START_INDEX, playlistOrder.length - 1);
      player.setShuffle(false);
      player.playVideoAt(currentIndex);
    } else {
      // fallback: for√ßa recarregar a lista depois de pequeno atraso
      setTimeout(() => {
        playlistOrder = player.getPlaylist() || [];
        if (playlistOrder.length) {
          currentIndex = Math.min(START_INDEX, playlistOrder.length - 1);
          player.playVideoAt(currentIndex);
        }
      }, 700);
    }

    // Some browsers require muted playback to autoplay ‚Äî mantemos inicialmente mudo, mas o utilizador pode desativar.
    player.mute();
    isMuted = true;
    muteBtn.textContent = 'üîá';

    // ligar UI
    attachUI();
    startUpdateLoop();
  }

  function onPlayerError(e){
    console.warn('YouTube player error', e);
  }

  function onPlayerStateChange(e) {
    const state = e.data;
    // estados: -1 (unstarted), 0 ended, 1 playing, 2 paused, 3 buffering, 5 cued
    if (state === YT.PlayerState.PLAYING) {
      isPlaying = true;
      playPauseBtn.textContent = '‚è∏';
      updateTrackInfo();
    } else if (state === YT.PlayerState.PAUSED) {
      isPlaying = false;
      playPauseBtn.textContent = '‚ñ∂';
    } else if (state === YT.PlayerState.ENDED) {
      isPlaying = false;
      playPauseBtn.textContent = '‚ñ∂';
      // se loop estiver ativo, avan√ßar ou repetir
      if (loop) {
        // se for √∫ltima, volta ao in√≠cio; sen√£o avan√ßa
        next();
      }
    }
  }

  // UI actions
  function attachUI(){
    playPauseBtn.addEventListener('click', togglePlayPause);
    prevBtn.addEventListener('click', prev);
    nextBtn.addEventListener('click', next);

    muteBtn.addEventListener('click', () => {
      if (!player) return;
      if (isMuted) {
        player.unMute();
        isMuted = false;
        muteBtn.textContent = 'üîä';
      } else {
        player.mute();
        isMuted = true;
        muteBtn.textContent = 'üîá';
      }
    });

    volSlider.addEventListener('input', (e) => {
      const v = parseInt(e.target.value,10);
      if (!player) return;
      player.setVolume(v);
      if (v === 0) {
        isMuted = true; player.mute(); muteBtn.textContent='üîá';
      } else {
        if (isMuted) { player.unMute(); isMuted=false; muteBtn.textContent='üîä' }
      }
    });

    progress.addEventListener('click', (ev) => {
      if (!player || typeof player.getDuration !== 'function') return;
      const rect = progress.getBoundingClientRect();
      const pct = Math.max(0, Math.min(1, (ev.clientX - rect.left) / rect.width));
      const duration = player.getDuration() || 0;
      if (duration > 0) {
        player.seekTo(duration * pct, true);
      } else {
        // se n√£o houver dura√ß√£o, tenta aproximar usando index e playlist item durations (n√£o dispon√≠vel aqui)
      }
    });

    shuffleBtn.addEventListener('click', () => {
      shuffle = !shuffle;
      shuffleBtn.style.opacity = shuffle ? '1' : '0.7';
      // a API tem setShuffle (YouTube IFrame) nos players embutidos s√≥ para playlists definidas.
      if (typeof player.setShuffle === 'function') {
        player.setShuffle(shuffle);
      } else {
        // fallback: embaralhar array localmente e reproduzir
        if (shuffle) {
          playlistOrder = shuffleArray(player.getPlaylist() || playlistOrder);
        } else {
          playlistOrder = player.getPlaylist() || playlistOrder;
        }
      }
    });

    loopBtn.addEventListener('click', () => {
      loop = !loop;
      loopBtn.style.opacity = loop ? '1' : '0.7';
    });

    // atualiza volume inicial
    volSlider.value = player.getVolume ? player.getVolume() : 20;
  }

  // play / pause
  function togglePlayPause(){
    if (!player) return;
    const state = player.getPlayerState();
    if (state === YT.PlayerState.PLAYING) {
      player.pauseVideo();
    } else {
      // tenta dar play com som se o utilizador tiver ajustado volume > 0
      player.playVideo();
    }
  }

  function prev(){
    if (!player) return;
    try {
      player.previousVideo();
    } catch (e) {
      // fallback: calcula index
      currentIndex = Math.max(0, currentIndex - 1);
      player.playVideoAt(currentIndex);
    }
  }

  function next(){
    if (!player) return;
    try {
      player.nextVideo();
    } catch (e) {
      currentIndex++;
      const list = player.getPlaylist() || playlistOrder;
      if (currentIndex >= list.length) {
        if (loop) currentIndex = 0; else currentIndex = list.length - 1;
      }
      player.playVideoAt(currentIndex);
    }
  }

  // update loop (tempo, progress)
  function startUpdateLoop(){
    if (updateTimer) clearInterval(updateTimer);
    updateTimer = setInterval(() => {
      if (!player || typeof player.getCurrentTime !== 'function') return;
      const dur = player.getDuration() || 0;
      const cur = player.getCurrentTime() || 0;
      const pct = dur > 0 ? (cur / dur) * 100 : 0;
      progressBar.style.width = pct + '%';
      timeLabel.textContent = formatTime(cur) + ' / ' + formatTime(dur);
      // atualiza t√≠tulo do v√≠deo atual
      updateTrackInfo();
    }, 500);
  }

  function updateTrackInfo(){
    if (!player || typeof player.getVideoData !== 'function') return;
    const data = player.getVideoData();
    if (data && data.title) {
      trackTitle.textContent = data.title;
    } else {
      // tenta extrair ID e escrever algo
      const playlist = player.getPlaylist() || playlistOrder;
      const idx = player.getPlaylistIndex ? player.getPlaylistIndex() : currentIndex;
      const vid = (playlist && playlist[idx]) ? playlist[idx] : '';
      trackTitle.textContent = vid ? ('V√≠deo: ' + vid) : 'A carregar...';
    }
  }

  // utilit√°rios
  function formatTime(t){
    t = Math.max(0, Math.floor(t));
    const m = Math.floor(t / 60);
    const s = t % 60;
    return m + ':' + (s < 10 ? '0' : '') + s;
  }

  function shuffleArray(arr){
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // fallback: se user interagir com UI, desmutar automaticamente se o volume > 0
  document.addEventListener('click', function onFirstClick(){
    if (!player) return;
    if (isMuted && volSlider.value > 0) {
      player.unMute();
      isMuted = false;
      muteBtn.textContent = 'üîä';
    }
    // s√≥ executar uma vez
    document.removeEventListener('click', onFirstClick);
  });

  // expor algumas fun√ß√µes para debugging (opcional)
  window._bgPlayer = {
    playerRef: () => player,
    next, prev, togglePlayPause
  };

  // utility: se a playlist n√£o for reconhecida imediatamente, tenta ler info com delay:
  // (j√° implementado no onPlayerReady)

  // IMPORTANT: O YouTube API chama globalmente onYouTubeIframeAPIReady, por isso coloc√°mos essa fun√ß√£o acima.
</script>
</body>
</html>
